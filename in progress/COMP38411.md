

# COMP 38411 Cryptography & System Security

Security can be classified into many different aspects, we only cover some of the topics in this course in the following order:

1. threads/vulnerabilities
2. cryptography algorithms/protocols
3. digital signature
4. data integrity
5. data management
6. trust

## Definitions

### Cryptography

It is the art of keeping messages secure by:

- prevent unauthorised entities from gaining access to resources
- scramble messages so that they cannot be understood by any unauthorized entities
  - cryptography is used

Its application includes:

- **Confidentiality** (secrecy, privacy) of data in transmission & storage
  - This ensures data **cannot be viewed** without unauthorized access.
- **Integrity** of data (data authentication / authenticity) in transit & in storage
  - This ensures data **cannot be changed** without unauthorized access.
- **Authentication** of an identity (entity authentication)
  - The act of verifying the identity, proof that it is indeed the identity.
- **Credential systems** (a proof of qualification or competence of a person)
- **Digital signatures**
- **Electronic money** (cryptocurrency, bit-coins)
- **Threshold cryptosystems** (a decryption key, or a signature signing key, is shared among a group of entities and a subset of these entities (more than some threshold number) have to collaborate to perform the decryption or signature signing).
- **Secure multi-party computations** (e.g. multiple parties compute a function jointly, the input is from the multiple parties, but no party should learn anything rather than its own input and the final result of the computation)
- **Digital right management** (e.g. activation of a software license by authorized users)
- ...

### Identification

The act of indicating a person or things identity.

### Authentication

It is the act of verifying the identity.

Ways someone maybe authenticated fall into three factors:

- knowledge: something that user knows
- ownership: something that user has
- inherence: something that user is or does

MFA involves more than one authentication factors.

### Authorization

After a person is authenticated, it must be determined what kind of resource he is allowed to access and what action he is allowed to perform. This is called authorization.

### Non-repudiation

This implies one party of the transaction cannot deny having received a transaction, nor can the other party deny having sent a transaction.

### Digital Signature

Associate a mark with text, can verify the authenticity of digital messages or documents. Gives strong reason that the message was created by a known sender.

#### Forgery

- Selective: attacker can generate a valid signature for an given message.
- Existential: attacker can generate a pair of message and signature that is valid.

Selective implies Existential.

### Ciphers (Cryptosystem)

- Symmetric-key based (conventional ciphers)
  - Same key is used for encryption and decryption.
- Asymmetric-key based (public-key ciphers)
  - Different keys are used for encryption and decryption.

#### Cryptoanalysis

An attempt to discover plaintext or key.

#### Secure

- **Unconditional**: the system cannot be defeated no matter how much power is available by the adversary.
- **Conditional**: the level of computational resources required exceeds the capacity of the hypothesized adversary.
- **Provably**: it can be verified to be secure.
- **ad hoc**: security is questionable and can be vulnerable to unforeseen attacks.

### Classical Cryptography

- Transposition Cipher: text permutation
- Substitution Cipher: text replacement

#### Transposition Cipher

It does not affects the frequency of words, thus if attacker do a frequency count and find its frequency distribution is similar to plaintext, it is likely a transposition. Then the attacker can try to use [anagramming](https://en.wikipedia.org/wiki/Anagram) to decrypt the ciphertext.

In some simple transposition ciphers, if you have a key that close to the correct key, it will result in revealing large section of plaintext which can be easily interpreted.

A double transposition cipher can be treated as a single transposition with a key as long as product of lengths of two keys.

#### Substitution Cipher

Simple substitution cipher (simply replace all "a" by "b") does not change the frequency distribution of the text. An early attempt is to disguise plaintext letter frequencies by homophony, where each letter map to more than one ciphertext symbol, usually the high frequencies letter will have more ciphertext symbols to flatten the frequency distribution.

#### Digital Signature

It is a mathematical scheme for **verifying the authenticity** of digital messages or documents. A valid digital signature gives very strong reason to believe that the message was created by a known sender (authenticity), and it is not altered during transmission (integrity).

It is often used to implement electronic signatures

### Classical Encryption Techniques

In cryptography, [**confusion** and **diffusion**](https://en.wikipedia.org/wiki/Confusion_and_diffusion) are two properties of the operation of a secure cipher, when present, they work to thwart the application of statistics and other methods of cryptoanalysis.

Classical algorithms are based on substitution & permutation.

#### Confusion 扰乱

Each character/bit of the ciphertext should depends on several parts of the key, this result in if one bit of the key is changed, then calculation of most bits in ciphertext will be affected, therefore **hiding the relationship between the ciphertext and key**. This make it difficult to find the key from ciphertext. One aim of confusion is to make it very hard to find the key even if one has a large number of plaintext-ciphertext pairs produced with the same key.

It can be achieved using **substitution (S-Boxes)** and normally used in both block and stream ciphers. A good implementation of S-Box will achieve [avalanche effect](https://en.wikipedia.org/wiki/Avalanche_effect), where if an input bit is changed, then it will cause more the half of the output bits to be changed (statistically).

#### Diffusion 扩散

Each bit change in plaintext/ciphertext should result in more than half of the bits change (statistically) in corresponding ciphertext/plaintext. This is to **hide the relationship between ciphertext and plaintext**.

It can be achieved using **permutation/transposition (P-Boxes)**, and normally used in block ciphers only.

### [One Time Pad (OTP)](https://en.wikipedia.org/wiki/One-time_pad)

It is an encryption technique that **cannot be cracked**, but requires the us of a one-time [pre-shared key (PSK)](https://en.wikipedia.org/wiki/Pre-shared_key). The following properties of the key must be met:

- Truly random.
- At least as long as plaintext.
- Never be reused.
- Completely kept secret.

It also also proven that any cipher with the property of perfect secrecy must use keys with effectively the same requirements as OTP keys, but the problem of secure key distribution made it impractical for most applications.

To sent a message, simply use a pad, then use a technique (e.g. modular addition) to generate the ciphertext, then destroy the pad immediately and send it to the receiver, then receiver picks up the ciphertext and use the same pad on her side, decrypt the message and destroy the pad immediately.

The only information given to the attacker is the maximum possible length of the plaintext, this is because the truly random key is used only once, a ciphertext can be translated into any plaintext of the same length, all equally likely.

## Public Key Certificate

It is an electronic document that used to prove the ownership of a public key.

## Ciphers

### [Substitution Cipher](https://en.wikipedia.org/wiki/Substitution_cipher)

#### Monoalphabetic - [Caesar Cipher](https://en.wikipedia.org/wiki/Caesar_cipher) (Shift Cipher)

Caesar cipher is a substitution cipher that encrypt the plaintext by replacing each letter with some fixed number of position down the alphabet. Monoalphabetic means that it maps plaintext to ciphertext based on a single alphabetic key.

With frequency analysis, the attacker can quickly notice caesar cipher is used, then he can break the scheme easily since there is only a limited possible shift (25 for English), he can also try to matches the frequency distribution and figure out the shift directly.

Also note that encrypting multiple times does not provide additional security

#### [Polyalphabetic](https://en.wikipedia.org/wiki/Polyalphabetic_cipher) - [Vigenere Cipher](https://en.wikipedia.org/wiki/Vigen%C3%A8re_cipher)

Polyalphabetic refers to ciphers that encrypt plaintext based on substitution that uses multiple substitution alphabets. Vigenere Cipher is a polyalphabetic cipher first described in 1553 that resisted all attempts to break it until 1863.

To encrypt the plaintext, choose a key and repeat it until it matches the length of the plaintext, then use a table with different shifts:

<img src="COMP38411.assets/image-20201205114207847.png" alt="image-20201205114207847" style="zoom:33%;" />

Then simply do: `ciphertext[i]=table[key[i]][plaintext[i]] for i in range(len(plaintext))`.

The idea behind the all polyalphabetic ciphers is to hide the letter frequency to interfere the straight forward application of frequency analysis. The primary weakness of Vigenere cipher is the repeating nature of its key, if a cryptanalyst correctly guesses the key length, then the ciphertext can be treated as interwoven Caesar ciphers, which can be easily broken individually.

### [Stream Cipher](https://en.wikipedia.org/wiki/Stream_cipher)

A symmetric key cipher where plaintext are combined with pseudorandom key stream. Each digit is encrypted one at a time with the corresponding digit of key stream. In practice, a digit is typically a bit and combined with xor operation.

### [Block Cipher](https://en.wikipedia.org/wiki/Block_cipher)

It is a deterministic algorithm that operate on a fixed number of bits called **block**. It uses symmetric key which means a unvarying transformation. A secure block cipher is suitable for the encryption of a single block of data, using a fixed key. In order to encrypt longer data, some people designed some [mode of operation](https://en.wikipedia.org/wiki/Block_cipher_modes_of_operation)s to use block cipher repeatedly in a secure way.

#### Iterated Block Cipher

Most block ciphers are iterated block cipher, which means both plaintext and ciphertext block **has the same size**, via repeated and invertible transformation called **round function**. Round function usually takes different **round key** $K_i$ that derived from the original key as second input. It is fairly easy to construct a cipher that is cryptographically secure by simply using a large number of rounds, but there are some other requirements:

- **Efficiency**: it need to be fast while meeting security requirement.
- **Avoid side-channels attacks**: avoid information in state of the machine, e.g. branch prediction, input-dependent memory access, cache state, execution time, etc.
- **Concise**: for small hardware/software implementation
- **Cryptanalyzable**: The minimum number of rounds for existing attacks work and conversely the rounds needed to be secure.

#### [Substitution-permutation Network (SPN)](https://en.wikipedia.org/wiki/Substitution%E2%80%93permutation_network)

It is a type of iterated block cipher where each alternating round consists of [substitution stage (S-Box)](https://en.wikipedia.org/wiki/Substitution_box) then followed by [permutation stage (P-Box)](https://en.wikipedia.org/wiki/Permutation_box).

#### Design Criteria

- **Completeness**: Each bit of the output should depends on every bit of the input and every bit of the key.
- **Avalanche effect (Diffusion)**
  - Changing one bit in the input should change many (statistically more than half) bits of the output.
  - Changing one bit in the key should change many (statistically more than half) bits of the output.
- **Statistically Independence (Confusion)**: The input and output should appear statistically independent.

#### Feistel Cipher

This is the implementation of the idea of substitution and permutation. It shows that a complex encryption function can be built out of some simple operations (round function) by repeatedly using them. These functions includes: **substitutions**, **permutation**, **xor**, **modular multiplication**. An important advantage of Feistel networks compared to other cipher designs such as [substitution–permutation networks](https://en.wikipedia.org/wiki/Substitution–permutation_network) is the entire operation is guaranteed to be invertible, it allows the round function to be arbitrarily complex and non-invertible. 

<img src="COMP38411.assets/image-20201207113534006.png" alt="image-20201207113534006" style="zoom:33%;" />

Note that at each round, you encrypt half of the text and xor with the other half, then you pass the xor-ed plaintext for next round to encrypt the current round un-encrypted other half.

- The round function $f$ typically uses substitutions/permutation/modular arithmetic, it takes n-bits and outputs n-bits, each round function uses a different subkey derived from $K$.
- Larger block size offer greater security but slower, typically $n$ is 128-bits or 256-bits.
- Larger key size offer greater security but slower, normally uses 128-bits.
- The number of rounds $r$ is typically $10+$.
- Encryption and decryption is the same, except keys in reverse order.

#### [Data Encryption Standard (DES)](https://en.wikipedia.org/wiki/Data_Encryption_Standard)

It is a Feistel block cipher. The algorithm is public, but the design principle is kept secret. It has a relatively short key size of 56, which publicly broken in 22 hrs and 15 mins in 1999.

- Block length = 64 bits.
- Key length = 56 bits, actually 8 bytes but the last bit is used for parity check.
  - Sub keys are each 48 bits, generated from key.
- Number of rounds = 16.

**Round Function Overview**

1. Expansion Permutation: Right half of input, 32 bits is expanded and permuted to 48 bits. Built-in trapdoors might be placed in secret boxes (?).
2. The 48 bits are xor-ed with the round key.
3. Split the xor-ed 48 bits to 8 slots of 6 bits each.
4. Each 6 bits is indexed to a different S-Box and outputs 4 bits.
   1. S-Box is a table, input's 1st and last bit select row and 2-5 bits select columns, convert the selected value in the table to 4 bits.
5. Permutate the 32 bits with P-Boxes.

#### Triple DES (3DES)

It applies DES cipher three times to each data block. It has key length of 168 bits, but the effective key length is much shorter due to man-in-the-middle-attack. Given a know plaintext pair $(x,y)$, such that $y=E_{K_1}(E_{K_2}(x))$, one can recover the key pair $(K_1,K_2)$ of key length $2n$, in $2^{n+1}$ steps instead of $2^{2n}$ steps. It is designed to have 80-bits security.

#### [Advanced Encryption Standard (AES)](https://en.wikipedia.org/wiki/Advanced_Encryption_Standard)

A call for algorithms to place DES was issued in 1997 with following requirements:

- Stronger & faster than 3DES
- Active life of 20-30 years.
- Provide full specification, and both Java and C implementation.

There are over 15 candidates accepted in 1998, 5 shortlisted in 1999 and Rijndael was selected as the AES in 2000 and formally nominated as AES in 2001. [See process](https://csrc.nist.gov/projects/cryptographic-standards-and-guidelines/archived-crypto-projects/aes-development).

AES is based on substitution-permutation network, it is efficient in both software and hardware, does not use the Feistel network, and it is a variant of Rijndael.

- Block length: 128 bits.
- Key length = 128/192/256 bits, corresponding to 10/12/14 rounds.

It operates on a 4x4 [column-major order](https://en.wikipedia.org/wiki/Row-_and_column-major_order) array of bytes called states.

1. **Key Expansion**: round keys are derived using [AES key schedule](https://en.wikipedia.org/wiki/AES_key_schedule).

2. **1st round**: Add round key: each byte of the state is xor-ed with each byte of the round key.

3. **2-(10/12/14) rounds**

   - Sub bytes: Replace bytes with a global 16x16 look-up table for all 256 8-bit values.

   - Shift rows: Left shift the last three rows.

   - Mix columns: Map each byte of a column to new value that is a function of all four bytes in the column, effectively a matrix multiplication in Galois Field ($2^8$) using a irreducible polynomial $m(x)=x^8+x^4+x^3+x+1\text{ or }11B $. For example:
     $$
     \begin{align*}
     \{02\}\cdot\{87\}\mod\{11B\}&=(0000,0010)(1000,0111)\mod\{11B\}\\
     &=(x)(x^7+x^2+x+1)\mod\{11B\}\\
     &=(x^8+x^3+x^2+x)\mod (x^8+x^4+x^3+x+1)\\
     &=x^4+x^2+1\\
     &=(0001,0101)
     \end{align*}
     $$

   - Add round key: (same as above)

4. **Final round**: sub bytes, shift rows and add round key (except mix columns).

#### DES vs AES

| **DES**                       | **AES**                            |
| ----------------------------- | ---------------------------------- |
| Substitution-Permutation      | Substitution-Permutation           |
| Iterated Cipher               | Iterated Cipher                    |
| block size=64-bits            | block size=128-bits                |
| key size=56-bits              | key size=128/192/256-bits          |
| Design optimized for hardware | Design optimized for byte-oriented |
| Closed design process         | Open design & evaluation process   |

#### Modes of Encryption

- **Electronic Codebook (ECB)**: Each block are encrypt independently, using the same key, last incomplete block is padded, usually the last byte indicate how many byte are padded, so that the receiver can remove them. It offers parallelizable encryption/decryption and random read access, but does not hide repeated pattern (lack of diffusion):

  <center><img src="COMP38411.assets/image-20201028083356450.png" style="zoom:33%;" /></center>

- **Cipher Block Chaining (CBC)**: The encryption of the current block depends on the previous block, thus it does not allow parallelizable encryption, but you still have decryption parallelizable and random read access, because decryption depends on the previous ciphertext which is already available.

  <center><img src="COMP38411.assets/image-20201207213056179.png" alt="image-20201207213056179" style="zoom:33%;" /></center>

- **Counter (CTR)**: The encryption uses the encryption function as key generator, remember the repeated keystream problem in stream cipher? This is how they solve this problem. The actual encryption is just the xor, which is same as the stream cipher, that's why some people says that with CTR, the block cipher is transformed into a stream cipher.

  - It has parallelizable encryption/decryption as well as random read access since you can compute the counter value of a block directly.
  - It also does not have error propagation, if one bit in a block is wrong during transmission, it does not affect the following block.
  - Its encryption and decryption function is the same, so you only need one function.
  - You can precompute the value to be xor-ed before you go online which made it fast.
  - Note that block has to be synchronized, if one block is removed then the plaintext cannot be recovered.

## Attacks

The security of any (modern) cipher is based not on the secrecy of an algorithm, but on the security of the cryptographic key. An attack is completely successful if the corresponding plaintext can be deduced, or even better, the key. But the ability to obtain any information at all about the underlying plaintext beyond what was pre-known to the attacker is still considered a success.

### Amount of Information Available

For the purpose of analysis, we assume the general algorithm is known. This is a reasonable assumption, throughout the history, there are countless examples where secret algorithms falling into wider knowledge.

|                                      | ciphertext | corresponding plaintext | chosen by attacker | choose while attacking | encrypt with two different keys |
| ------------------------------------ | ---------- | ----------------------- | ------------------ | ---------------------- | ------------------------------- |
| Ciphertext-only (Known-ciphertext)   | yes        |                         |                    |                        |                                 |
| Known-plaintext                      | yes        | yes                     |                    |                        |                                 |
| Chosen-plaintext/ciphertext          | yes        | yes                     | yes                |                        |                                 |
| Adaptive chosen-plaintext/ciphertext | yes        | yes                     | yes                | yes                    |                                 |
| Related-key                          | yes        | yes                     | yes                |                        | yes                             |

### Brute-force attack (exhaustive key search)

It is done by trying out all possible keys, three properties is required:

- Encryption and decryption algorithms are known.
- Key space should be small enough.
- The language of plaintext is easily recognizable.

### Frequency Analysis

It is based on the fact that, in any given stretch of written language, certain letters and combinations of letters occur with varying frequencies. If the distribution of frequencies of letters in ciphertext is similar to distribution of plain language, then it can be exploited by the attacker. 

### Man-in-the-middle Attack



## Public Key

The problem with symmetrical key cipher:

- Two or more parties share the same key, non-reputation cannot be achieve without trusted third party.
- A separate key is needed for each user, or even each session. So if $n$ users wants to communicate with each other, we need $n\times(n-1)/2$ keys, the $n^2$ problem.
- Generating/distributing/maintaining these keys are challenging.

The idea of public key is based on trapdoor (one-way) function $f$:
$$
\begin{align*}
&C=f(K,M)&&\text{easy if K, M are known}&\\
&M=f^{-1}(K,C)&&\text{easy if K, C are known, infeasible if only C is known}&\\
\end{align*}
$$
Commonly used one-way function includes:

- Integer Factorization (RSA): given $N$, find $N=p\times q$ where $p$ and $q$ are prime.
- Discrete Logarithm (DSS & DH): given $a,b,p$, find $x$ in $a^x=b\mod p$ where $x\in \Z$.

### RSA

<img src="COMP38411.assets/image-20201208154910383.png" alt="image-20201208154910383" style="zoom: 50%;" />

<img src="COMP38411.assets/image-20201208154927039.png" alt="image-20201208154927039" style="zoom:50%;" />

<img src="COMP38411.assets/image-20201208154948730.png" alt="image-20201208154948730" style="zoom:50%;" />![image-20201208155010251](COMP38411.assets/image-20201208155010251.png)

<img src="COMP38411.assets/image-20201208154948730.png" alt="image-20201208154948730" style="zoom:50%;" />

<img src="COMP38411.assets/image-20201208155010251.png" alt="image-20201208155010251" style="zoom: 50%;" />

As a receiver, RSA allows you to ensure data integrity, because it is unlikely for anyone except you who has the private key to decrypt the message, but you cannot ensure who sent it to you. As a sender, RSA allows you to ensure only the receiver can see the content of the message because only he has the key that allows him to easily decrypt the ciphertext.

### Applications

![image-20201208115445761](COMP38411.assets/image-20201208115445761.png)

- **Confidentiality**: You can encrypt with public key so that you know that message can only be decrypted by the other.
- **Authenticity**: You can encrypt with private key so that others know the message comes from you.

timestamp not in slip

## Cryptographic Checksum

### Reason

- **Symmetric Encryption**: No non-repudiation, sender can deny sending the message and receiver and make up a encryption and say that it is from the sender.
- **Public-key Encryption**: No original authentication, anybody can hold receiver's public key.
- **Digital Signing**: Provides authentication, non-repudiation and anti-replay, it is signed using sender's private key, and anyone can verify the checksum with sender's public key. But it does not provide confidentiality. It is useful for application that only requires authentication, e.g. secure broadcast and source code distribution, as it is hard to forge and tamper-proof.

### Hash Function

A hash function $H$ takes $M$ of any length, and output a fixed size $h$, called checksum/digest/hash/fingerprint with following requirements:

- **Preimage Resistant (one-way function)**: given $h$ and $H$, it is infeasible to find $M$ for $H(M)=h$.
- **2-nd preimage Resistant (weak collision-resistant)**: given $x$ and $H$, it is infeasible to find $x'$ for $H(x)=H(x')$.
  - Hard for someone to change the message in transit.
- **Collusion Resistant (strong)**: It is infeasible to find any two $x$ and $x'$ for $H(x)=H(x')$.
  - Hard for sender reputation.

Note that it is a many-to-one function and we need to reduce collusion, and strong resistant implies weak resistant.

<center><img src="COMP38411.assets/image-20201208172625595.png" alt="image-20201208172625595" style="zoom: 50%;" /></center>

 Note that the hash function alone only provides data integrity but not authenticity.

### Message Authentication Code (MAC)

The checksum can also be generated using a symmetric block cipher, e.g. CBC-MAC. If only sender and receiver knows that key used for generating MAC, then the receiver knows the message is:

- Integrity protection: MAC matches.
- Origin authentication: only sender and receiver has the key to generate the MAC
- The message is in correct order, if the message includes a sequence number.
- Fresh message, if the message includes a timestamp or a random number created  (fully/partial) by receiver.

Note that MAC is not digital signature and does not provide non-repudiation.

#### HMAC

HMAC is a keyed hash function: $HMAC(K,M)=H(K^+_o,H(K^+_i, M))$, where $K^+_o$ and $K^+_i$ and the key padded to block size and xor-ed with opad (00110110, 0x36) and ipad (01011100, 0x5c).

#### Security

The security of MACs depends on the bit-length $n$, finding collusions costs: $2^{n/2}$.

## Lecture 1-2

## History & Present

- Very old days, before large-scale application of the internet
  Interest in security were largely confined to military domain.
- 1988: Morris worm brought down a large fraction of the internet.
- late 80s: E-commerce, ATM, financial transactions
- early 90s: Mosaic and Netscape (early search engines)
- Mobile
- Cloud
- Crypto currencies, smart contract signing, getting rid of third parties, block chain
- IoT

## Threats & Challenges

- 444129 ransomware attacks took place worldwide in 2018.
- 300000 new malware are created daily.
- 75 records are stolen every second.
- A consumer account can be as cheap as 1 dollar.
- More than 6000 online criminal marketplace sell ransomware products/services.

Threads in generic context (Confidentiality, Integrity & Availability (CIA))

- Disclosure (confidentiality)
  - Snooping/sniffing
  - Unauthorized access
- Deception
  - Spoofing (identity theft)
  - (integrity)
    - Unauthorized data modification
    - Replay (intercept & retransmit)
    - Repudiation (false denial) of origin/receipt
- Disruption (availability)
  - modification, delay, Denial of Services (DoS)

Specific Threads (Top 5)

1. Social Engineering Attacks: relate to people.
2. Supply Chain Attacks: relate to system, payment, etc.
3. IoT & Infrastructure Attacks: relate to infrastructure, organizations (they usually have their own network).
4. Identity & Mobile Authentication: like Multi-Factor-Authentication (MFA), relate to high value assets.
5. Rise of Zero-Day Threats & Polymorphic Attack: related to malware, this refers to vulnerabilities that is found and fixed, but patch has not been applied to the system.

- Most attack is done through malware.
- There are hacking-as-a-service nowadays
  
- People do not have to be very knowledgeable to launch attacks because there are many available tools.
  
- Spectrum of risks increases as degree of digitization increases.

  - e.g. messaging<storing information<transactional system<technology integration<fully integrated information based business

- Infrastructure relationships in cyberspace

  1. Physical Infrastructures: nuclear plants, hospitals, cable fiber, farms, etc.
  2. Critical Infrastructures/Key Resources(CIKR): comms, water/gas/oil, transportation, emergency, banking, etc.
  3. Cyber Infrastructures: hardware, software, interconnected network (internet), etc.

  <img src="COMP38411.assets/image-20201015162903459.png" alt="image-20201015162903459" style="zoom:33%;" />

- Naive users: lack of security awareness
- Inadequate management procedures
  - Insecure system set up and configuration
  - Lack of proper policy making, implementation and enforcement procedures.
- Global networks without national boundaries
- Heterogeneous devices, laptop, phones with universal connection
- Anonymous nature of many Internet-based services.

<img src="COMP38411.assets/image-20201015164303066-1606680319648.png" alt="image-20201015164303066" style="zoom:33%;" />

## Lecture 1-3

### Achieving Security

There is three basic security properties that is commonly seen in real life (CIA):

- Confidentiality
  - Keeping data & resources hidden
- Integrity/Authenticity/Authentication
  - Content integrity (detect modification & replay)
  - Origin integrity (data is indeed from claimed source)
- Availability
  - Ensuring data/service is available to authorized users.

There are also other advanced security properties:

- Freshness
  - Ensure data is not a replay/retransmission of old data
- Non-repudiation
  - Protect against false denial.
- Fairness
  - Either all parties are received or no party received something useful.

In order to achieve security we go through following steps:

1. define security goals
   1. threads analysis & identification: what to protect against
   2. policy/requirement specification: define what is/is-not allowed
2. design & implement
   1. decide how to protect as to satisfy the specification
      1. technical measures
      2. procedural measures
3. operation maintenance
   1. assess how well the implementation has achieved the security goal

In term of thread analysis:

- identify assets, threads and vulnerabilities.
- assess the levels of risks on the assets
  - value
  - importance: likelihood of exploitation
  - not all threats is worth defeating
    - cost vs benefit analysis, prevent vs recover vs ignore.

This can be carry out using an attack tree. It is a conceptual diagrams (usually tree-like) showing how an asset, or target, might be attacked. Child nodes are conditions that must be satisfied to make the direct parent node true. Conditions can be OR or AND.

<img src="COMP38411.assets/image-20201015211420565.png" alt="image-20201015211420565" style="zoom:33%;" />

Security measures is a method, protocol, tool or used to address the risks identified (or enforce security policy)

- prevention
  - block attacks by closing vulnerabilities
  - reduce level of risk by making attack harder
  - make other more attractive target (honey pot)
  - e.g. access control (firewalls), encryption, digital signatures, etc.
- detection
  - measures taken before/after the attack
  - e.g. logging, auditing & intrusion detection
- recovery
  - assess & repair damage
  - continue to function correctly even if attack succeeds
- accept
  - accept it and do nothing (if some threats are not worth it).

Operation & maintenance

- assurance
  - testing to check the correct implementation
  - formal evaluation
  - standards
    - US Security Evaluation Criteria (the orange book)
    - European ITSEC (Information Technology Security Evaluation Criteria)
- Human Issue
  - organizational issue
    - power & responsibility
    - financial benefits
  - people problems
    - outsiders & insiders
    - social engineering

Putting together:

<img src="COMP38411.assets/image-20201015213317539.png" alt="image-20201015213317539" style="zoom:33%;" />

### Security Models

When designing a security model, we have to think what are the security threats in this model and what are the properties/services that are necessary to counter the threats? There are many issue to think of:

<img src="COMP38411.assets/image-20201016093938543.png" alt="image-20201016093938543" style="zoom:33%;" />

Lets first consider a communication security model. This model emphasis on protecting the data over the channel, security properties we interested are authenticity and confidentiality.

<img src="COMP38411.assets/image-20201016095816740.png" alt="image-20201016095816740" style="zoom:33%;" />

If we only consider the receiver, we have the following multi-layer network security model:

```mermaid
graph LR
subgraph perimeter
fw[firewall]
end

subgraph network
net[intrusion detection]
end

subgraph host
auth[auththentication<br>authorisation<br>availability<br>virus scan]
end

request --> fw --> net --> auth
auth --> applications
auth --> resources
```

We also have other model, such as the E-commerce security model, in this case, the customer and merchant does not trust each other, instead, they introduce a trusted third party (TTP) that offer some services.

<img src="COMP38411.assets/image-20201016105709015.png" alt="image-20201016105709015" style="zoom:33%;" />

### Conclusion

Network & distributed systems are part of our daily lives. Most systems are networked which open to many attacks and threats, security provisioning is a complex task, it consists of computers/software/wired/wireless network/processes, and the weakest link is people.

## Lecture 2-1

Cryptography is the art of keeping messages secure — Scheier

Keeping message secure is done either prevent the unauthorized access or encrypt the message, the later use cryptography, nowadays cryptography is more widely used, it can be found in:

- authentication of an identity
- credential systems: a proof of qualification or competence of a person.
- confidentiality: secrecy and privacy of data in transmission and storage
- integrity of data: data authentication/authenticity in transit and in storage
- digital signatures
- electronic money: cryptocurrency, bitcoins

Application:

- Threshold cryptography: shared decryption key within entities, a subset of entities have to collaborate and perform decryption/digital signature
- Multi-party computation: compute a function together, one party should only know their own input and the output of the function.
- Digital right management: activating software license
- electronic voting
- …

We will focus on achieving confidentiality using encryption

- ciphers (cryptography system)
  - symmetric-key (same key used for encryption and decryption) (conventional ciphers) (before 1976)
  - asymmetric-key (different key used for encryption and decryption) (public-key ciphers)
- ciphertext: message in encrypted form
- cipher/cryptosystem: the system that performs encryption and decryption
- cryptanalysis: attempt to discover plaintext or key

- unconditional secure: cannot be defeated regardless of how much power is available
- conditional secure: perceived level of computation required exceeds the computational resources of the hypothesized adversary. e.g. takes very long time to break.
- provably secure: some solution can be verified that it is secure
- adhoc security: claims of security remain questionable

## Lecture 2-2

classical encryption techniques

```mermaid
graph TB
cc[classical ciphers] --> sc[substitution ciphers]
cc --> tc["transposition (permutable) ciphers"]
sc --> m["monoalphabetic<br>(e.g. caesar cipher)"]
sc --> p["polyalphabetic<br>(e.g. vigenere cipher)"]
```

- monoalphabetic: a character always replaced by another same character
- polyalphabetic: a character maybe replaced by multiple other characters

classical algorithms uses:

- substitution (confusion): a -> b
  - modern ciphers look up table that transform input: S-Boxes (transforming block of nbits)
- permutation (diffusion): ab -> ba
  - modern ciphers look up table that transform input: P-Boxes (transforming block of nbits)
- XOR operator: efficient in computers
- simple/non-secure ciphers:
  - shift ciphers: caesar cipher
  - vigenere cipher
- secure cipher: one time pad

Note that modern ciphers operates on bits rather than characters

caesar cipher (shift cipher) basically uses addition and modulo, encryption is circular right shift and decryption is circular left shift. This algorithm is very unsecure.

- easily break by brute force (exhaustive key search) 

  - only 25 keys to try
  - algorithm is in public domain
  - language of plain text is easily recognized, not compressed.

  given small amount of plaintext-ciphertext pair, encrypted with key K, K can be recovered by exhaustive key search with in $2^{n-1}$ processing complexity, where n is the bit-length of the key.

  redundancy in plaintext can be exploit, e.g. the letter "e" appear frequently, so the most common letter in encrypted text is likely to be "e". This is called frequency analysis (counting attack), which based on study of frequency of letters in ciphertext.

  With today's computing power, the key should at least be 128 bits long.

## Lecture 2-3

One type of modern cipher is stream cipher and one type of stream cipher is based on one time pad

### Vigenere Cipher

Recall that caesar cipher has the problem of frequency of words which can be exploit by hackers, we should hide this information, this can be done easily by changing just a bit of the algorithm. We can shift each letter by different number, so that the ciphertext does not contains the frequency information. We usually use a keyword, e.g. bed->143 (this shift letters bed by different amount). This is called vigenere cipher. It is significantly more secure than regular cipher, its security level depends on the keyword length.

#### One Time Pad

Ofcourse, instead of using keyword, it can be just a random text, if we use a random text that as long as the password, then we have a cipher with perfect secrecy, when used properly, it is provably unbreakable (Shannon, 1949). This algorithm is proposed by Gilbert Vernam during WWI. It is a special variant of stream cipher. Typically a stream cipher uses mod 2, XOR function.

However, this method is not practical because the storing and distribution of the key can be troublesome.

#### Stream Ciphers

Stream ciphers encode individual bits or character stream with a keystream, usually xor is used, because xor has a nice property: A xor K = B and B xor K = A. Instead of generating random sequence in one time pad, stream ciphers usually only keep a key and use that key to generate pseudo-random sequence for encryption and decryption.

```mermaid
graph LR
subgraph encryption
g1[pseudo-random byte generator] --> xor1[xor]
end
subgraph decryption
g2[pseudo-random byte generator] --> xor2[xor]
end
xor1 --> c[ciphertext byte stream]
c --> xor2
k --> g2
pt[plaintext byte stream] --> xor1
k[key] --> g1
xor2 --> pt2[plaintext byte stream]
```

#### Transposition Cipher

It generate ciphertext by reordering the plaintext. e.g. write row by row and read column by column

#### Attacks

Note that modern cipher is based on the security of the key, not the secrecy of the algorithm itself.

- frequency attacks: break by spotting flaws in algorithms
- brute force/exhaustive key search: try every possible key
- dictionary attacks: run encryption algorithms on a massive amount of plaintext until the same ciphertext appears.

When it comes to password, it usually has a problem: do we use the password as key or plaintext? The latter creates more problems because now we have to think of another key and we have to ensure its security, so password is often the key. This way, the ciphertext is not reversible unless hacker knows the password.

- ciphertext-only attack (e.g. frequency attack): attacker knows ciphertext of several messages encrypted with the same key, then from here they try to find the key.
- known-plaintext attack (e.g. dictionary attack)
   ciphertext attack + they know the plaintext of these messages,
- chosen-plaintext attack: attacker choose some plaintext and have their corresponding ciphertext, from here they find the key. E.g. attacker change some letters and observe the change of power consumption of the encryption process.

Cryptographic attack often exploit the redundancy of natural language, so lossless compression before the encryption is often used before encryption to remove redundancy

## Lecture 3-1

#### Block Cipher

divide plaintext into blocks and encrypt one at a time, padding is added for incomplete block (?potential exploit?)

Criteria

- **completeness**
  every bit of the output should depend on every input bit, so that the output will change even if only 1 bit is changed in input.
- **avalanche effect (diffusion)**
  one bit change in message/key should change many bits in output
- **statistical independence (confusion)**
  input and output should be statistically independent. So that the attacker cannot guess certain text with probability

Claude Shannon identified that confusion can be achieve by substitution and diffusion can be achieve by permutation. Horst Feistel later then design a block cipher structure that implement this idea, in this structure he also prove that complex encryption function can be built out of some simple operation by repeatedly using them. e.g. substitutions/permutations/xor/modular multiplication. Network that use substitution and permutation are also called SP-network.

##### Feistel Block Cipher

- permutation
- spilt into 2 halves
- 16 rounds of identical operations with different keys (subkey/round key)
- inverse permutation

<img src="COMP38411.assets/image-20201022151635660.png" alt="image-20201022151635660" style="zoom: 33%;" />

Its important advantages is that the encrypted message can be decrypted even if the round function F is invertible. It also has other advantages, includes only xor is needed and encryption and decryption is almost identical, so implementing it is simpler than the usual SP-network.

- The function F takes n bits and output n bits, usually permutations, substitutions or modular arithmetic.
- larger block size usually means greater security but make encryption/decryption slower, typically 128/256 bits.
- key size is usually 128, larger the better but reduced speed as well.
- number of rounds is usually 10+, wikipedia says 4 rounds are enough for a strong pseudorandom permutation. 

### Lecture 3-2

des is a feistel block cipher, block length is 64, but 8 bits (every 8th bit) are used for parity check, so effectively 56bits. Key is 56bits, subkey is 48bits
<img src="E:/back ups/new/typora-user-images/image-20201022163713801.png" alt="image-20201022163713801" style="zoom:33%;" />50%;" />

Round Function f:

1. expansion permutation: right half (32bits) is expanded to 48bits
   - use a permutation table, e.g. 4->8bits: 41232341, this is to achieve avalanche effect.
   - 32->6x4bits, 6 -> 1and6th bits for row, 2-5th bits for col, row and col then can be used to index a 2x16 table, each cell contains a 4bits number, so each 6bits generate new 4bits, so we have generated 4x4=16 new bits
2. use of round key: 48 bits are xor with the round key
3. splitting: 48-> 8 x 6 bits each
4. S-box: each 6 bits is indexed against a S-box to produce 4bits result
5. P-box: permute the 32bits from S-box = output of f

Strength of des:

des's weakness is the key size, which is 56 bits, with the increasing computational power, this is no longer secure. We have two options:

- repeat: triple des

  - two variens, 2 keys (112bits) or 3 keys(168bits)
  - $C=E_{k1}(D_{k2}(E_{k3}(M)))$, the reason for using decryption in the middle is just for backward compatibility, a user using the old des method can simply set the keys to be the same to communicate with another user that uses triple des.
  - people found that they can use meet in the middle attack to break the algorithm within shorter time than 2^bits:
    - build a table of keys, k
    - compute encryption(k, M)
    - eavsdrop a value f(k', M)
    - if f(k,M)=f(k',M) then it is likely that k=k'
    - Precondition for this attack is that attackers have to have pairs of (M, C)

- new standard: aes

  - US NIST issued call for DES replacement in 1997 with requirements:
    - stronger & faster
    - active life 20-30 years
    - provide full specification & design details
    - both c & java implementation
  - 15 accepted in 98, 5 shortlisted in 99, Rijndael was selected in 2000 and nomiated as AES in 01

  like des, aes is a symmetric block cipher, same key for E and D, plaintext and ciphertext has the same size.

  different from des, aes is iterative rather than feistel cipher, its block size is 128, others allowed but not recognized by the standard, key lengths are 128/192/256, i.e. the standard consists of three block ciphers. It is a substitution=permutation cipher incolving r rounds, 128->r=10, 192, r=12 and 256->r=14

  aes has fixed block size of 128bits(16bytes) called a state.

  Each round has 4 operations:

  - substitute bytes (subBytes)
    - S-box that replace each byte by another byte, stored in a single 16x16 (256) matrix (left 4 bits for row and right 4 bits for column)
  - shift rows (shiftRows)
    - it is a simple circular byte shift, 1st row -> no change, 2nd row -> 1-byte circular left shift, 2-byte circular left shift, 4th row -> 3-byte circular left shift. It permutes bytes between the columns. 
    - decryption just use right shift instead
  - mix columns (mixColumns)
    - a matrix multiplication in GF(2^8) (Galois Field), using irreducible polynomial m(x)=x8+x4+x3+x+1. if result is more than 8 bits, the extra bits is cacelled out by xor with the 9 bit string 100011011.
      <img src="COMP38411.assets/image-20201027174408546.png" alt="image-20201027174408546" style="zoom:33%;" />
    - Together with shift rows, it achieve diffusion.
  - add round key (addroundKey)

  It is a seqential and light weight schedule

  we can see that the mix-column output each byte output based on all four columns in the previous state, so it has good avalanche effect (diffusion).

  the decryption is different from the encryption algorithm, where inverse of each operation is used.

  There are two ways of implementing decryption, we need to investigate.
  <img src="COMP38411.assets/image-20201027175048688.png" alt="image-20201027175048688" style="zoom: 33%;" />

### Lecture 3-4

If message is longer than block size, we need a way to encrypt these blocks, there are three standardlized modes:

- **ECB**: Electronic Code Book.
  Each block are encrypt independently, using the same key, last incomplete block is padded, usually the last byte indicate how many byte are padded, so that the receiver can remove them. It offers parallelizable encryption/decryption and random read access, but does not hide repeated pattern (lack of diffusion):
  <img src="COMP38411.assets/image-20201028083356450.png" alt="image-20201028083356450" style="zoom:50%;" />
  Thus it is not recommeded for encrypting data more than the block size.
- **CBC**: Cipher Block Chaining.
  $C_i=E_k(M_i\ XOR\ C_{i-1})$. The encryption of the current block depends on the previous block, thus it does not allow parallelizable encryption, but you still have decryption parallelizable and random read access, because decryption depends on the previous ciphertext which is already available.
  ![image-20201028083710483](E:/back ups/new/typora-user-images/image-20201028083710483.png)
- **CTR**: Counter. It uses the encryption function as key generator, remember the repeated keystream problem in stream cipher? This is how they solve this problem. The actual encryption is just the xor, which is same as the stream cipher, thats why some people says that with ctr, the block cipher is transformed into a stream cipher.
  - It has parallelizable encryption/decryption as well as random read access since you can compute the counter value of a block directly.
  - It also does not have error propagation, if one bit in a block is wrong during transmittion, it does not affect the following block.
  - Its encryption and decryption function is the same, so you only need one function.
  - You can precompute the value to be xor-ed before you go online which made it fast.
  - Note that block has to be synchronized, if one block is removed then the plaintext cannot be recovered.
  - <img src="COMP38411.assets/image-20201028084253284.png" alt="image-20201028084253284" style="zoom:33%;" />

Block vs Stream:

- Block cipher encrypts blocks of characters, stream cipher encrypt individual character or bit streams.
- Stream cipher is usually faster than block cipher, used in real-time/continuous communication/applications.
- Stream cipher have limited or no error propagation, so advantage when bit error are probable.
- Can be built using block cipher with CTR mode.

## Lecture 4-1

Public key cryptography

Up to this point we are just learning about cryptography schemes based on shared secret (symmetric). There are some problems with this approach:

- two/more parties share the same key, non-repudiation cannot achieved without involvement of a trusted third party.
- A distinct key is needed for every pair of users, or even for each session/encryption. So n-users system requires n \* (n-1) keys (n^2 problem).
  - It is hard to maintain security of these keys.

Public Key Cipher are different, they are based on one-way/trapdoor functions which based on mathematically hard problems. These function is hard to compute the reverse if the secret is unknown. Some hard problem includes:

- integer factorization: given n, find prime p and q such that p \* q = n. Used in RSA.
- discrete logarithm: given a,b,c, find x such that a^x=b mod c. Used in DSS and DH.

among proposed pk algorithms, some are suitable for encryption (+ key distribution), some are useful for digital signatures, e.g. DSA and DSS, some are for key agreement, e.g. DH algorithm. Only RSA, ElGamal and Rabin works well for both encryption and digital signatures.

#### Confidentiality (保密性)

```mermaid
graph LR

subgraph Alice
m1[Message] --> Encryption 
end
Encryption --> ct[Cipher Text] --> Decryption
p[Bob's public key] --> Encryption
subgraph Bob
Decryption --> m2[Message]
prk[Bob's private key] --> Decryption
end
p --> Decryption
```

It is secure (only Bob can receive) because only with Bob's private key can decrypt the message.

Note that this confidentiality should only be applied to short messages, e.g. symmetry key (?).

#### Authenticity (真实性)

```mermaid
graph LR
subgraph Alice
m1[Message] --> Encryption
aprk[Alice's private key] --> Encryption
end
Encryption --> ct[Cipher text] --> Decryption
apuk[Alice's public key] --> Decryption
subgraph Bob
Decryption --> m2[Message]
end
```

Signature is signed on the hash value of M, and a timestamp should be included, to avoid attacker to send the same message twice. Can be used for signature.

It is authentic (must from Alice) because only Alice's public key can decrypt that message.

### Modular Arithmetic

if a = b mod n, then we have a = k\*n+b

<img src="COMP38411.assets/image-20201103170324657.png" alt="image-20201103170324657" style="zoom: 33%;" />

#### Euler's Theorem

if n is prime then $\phi(n)=n-1$, where $\phi$ refers to the number of integers less than n is relatively prime to n.

if p,q are prime and n=p\*q then $\phi(n)=\phi(p\times q)=(p-1)\times(q-1)$

$a^{\phi(n)}=1\mod{n}$.

## Lecture 5-1

### Checksum

<img src="COMP38411.assets/image-20201110110817423-1606680636397.png" alt="image-20201110110817423" style="zoom:33%;" />

<img src="COMP38411.assets/image-20201110111510465.png" alt="image-20201110111510465" style="zoom:50%;" />

- a certain degree: e.g. if M is binary file then it is hard for B to check if M is altered or not, the variant has a checksum, we can use this to verify if M is correct.

<img src="COMP38411.assets/image-20201110112910277.png" alt="image-20201110112910277" style="zoom:50%;" />

<img src="COMP38411.assets/image-20201110113228023.png" alt="image-20201110113228023" style="zoom:50%;" />

![image-20201110114244627](COMP38411.assets/image-20201110114244627.png)

<img src="COMP38411.assets/image-20201110114923023.png" alt="image-20201110114923023" style="zoom:33%;" />

<img src="COMP38411.assets/image-20201110153820655.png" alt="image-20201110153820655" style="zoom:33%;" />

- strong is different from weak collision, the weak collusion says that given a hash value, find another input that has this hash value, the strong collusion  says that find any two inputs that has the same hash value.
  - if not weak collusion, then someone can intercept your message and send another message with the same hash function
  - if not strong collusion, then someone can find two different messages, send one of them and later claim that it is the other one, e.g. pay \$10 for an item, then ask for \$100 refund, because they have the same signature.



SHA-1 is no longer secure by today's computing power.

<img src="COMP38411.assets/image-20201110160807630.png" alt="image-20201110160807630" style="zoom:33%;" />

<img src="COMP38411.assets/image-20201110160928700.png" alt="image-20201110160928700" style="zoom:33%;" />

<img src="COMP38411.assets/image-20201110161442800.png" alt="image-20201110161442800" style="zoom:33%;" />

### MAC

Message Authentication Code, HMAC= hash function based MAC. 

<img src="COMP38411.assets/image-20201110161636558.png" alt="image-20201110161636558" style="zoom:50%;" />



The origin is ensured/authenticated, you can use block cipher to generate it.

<img src="COMP38411.assets/image-20201110161819937.png" alt="image-20201110161819937" style="zoom:50%;" />

<img src="COMP38411.assets/image-20201110162259994.png" alt="image-20201110162259994" style="zoom:33%;" />

<img src="COMP38411.assets/image-20201110162029525.png" alt="image-20201110162029525" style="zoom:33%;" />

k1 and k2 is derived from the input key.

MAC cipher (symmetric key) is designed for encryption and hash function is designed as one way function for digesting, so hash is generally faster.

<img src="COMP38411.assets/image-20201110162531173.png" alt="image-20201110162531173" style="zoom:33%;" />

Note that if you do not trust each other, then you should use HMAC, as MAC does not provide repudiation.

### Authenticated Encryption

For authentication and confidentiality. Tag is for authentication

- hash-then-encrypt: E(K, (M||H(M)))
- MAC-then-encrypt: E(K2, (M||MAC(K1,M))) or Tag=(MAC(K1, M)), E(K2, (M||Tag)) –> used in SSL
  - you do not need 2 keys, but you can
- encrypt-then-MAC: C=E(K2,M), Tag=MAC(K1,C) –> used in IPSec
- encrypt-and-MACC=E(K2,M), Tag=MAC(K1,M) –> used in SSH

If you MAC then encrypt, then receiver will have to decrypt before he can check the hash value, so we need to consider use case. if receiver can check mac first, then it is more resilient to DDOS attack.

### AEAD

Different data may requires different protection:

<img src="COMP38411.assets/image-20201110165711363.png" alt="image-20201110165711363" style="zoom:33%;" />

<img src="COMP38411.assets/image-20201110165924259.png" alt="image-20201110165924259" style="zoom: 33%;" />

<img src="COMP38411.assets/image-20201110165945272.png" alt="image-20201110165945272" style="zoom: 33%;" />

### CCM

counter mode with CBC-MAC

CBC encrypt data sequentially, it is slow, so we want to use GCM

<img src="COMP38411.assets/image-20201110171045353.png" alt="image-20201110171045353" style="zoom:33%;" />

<img src="COMP38411.assets/image-20201110171027389.png" alt="image-20201110171027389" style="zoom:33%;" />

### GCM

Galois/Counter Mode

<img src="COMP38411.assets/image-20201110171127446.png" alt="image-20201110171127446" style="zoom:33%;" />

nonce=random number

<img src="COMP38411.assets/image-20201110171523117.png" alt="image-20201110171523117" style="zoom:33%;" />

A=authentication data, C=ciphertext, T=authentication tag

<img src="COMP38411.assets/image-20201110171656025.png" alt="image-20201110171656025" style="zoom:33%;" />

The H hash value only depends on the K, so it is fast. The Galois field in AES is 8 bit, here is 128 bits.

<img src="COMP38411.assets/image-20201110171907150.png" alt="image-20201110171907150" style="zoom:33%;" />

All we do is xor in sequential which is fast, each value in bracket can be computed independently.

<img src="COMP38411.assets/image-20201110172001871.png" alt="image-20201110172001871" style="zoom:33%;" />

This is stream cipher, so you do not have to pad it, if the encrypted message is longer than the remaining message, then you just take the most significant bits (MSB).

<img src="COMP38411.assets/image-20201110172210399.png" alt="image-20201110172210399" style="zoom:33%;" />

We only increment the right most 32 bits. This is to can keep sender and receiver counter value synchronized and the inc function is not increased sequentially which make it more secure.

<img src="COMP38411.assets/image-20201110173404233.png" alt="image-20201110173404233" style="zoom:33%;" />

# Miscellaneous

### Why Encryption Standard

So that everyone can try to attack and break this algorithm. Keeping the same standard can offer ease of communication between different parties using the same encryption. Normally we want algorithm to achieve security goal and be as fast as possible, increasing the bit size will make the algorithm slower and maybe another algorithm will be better, so people do not just increase the bit size, they come up with new standard. For today's computer power, bit size should be at least 128.

### 3DES is broken

When a cryptographer says "broken," that means something very specific: that an attacker can break the key in better-than-brute-force time. 3DES has a key length of 168 bits, which is reduced to 112 bits by some meet-in-the-middle attack cleverness. And, to quote Wikipedia, "it is designated by NIST to have only 80 bits of security."

### Authenticity and Non-repudiation

- Authenticity is sender verifying to receiver that he is the people who sent the message.
- Non-repudiation is a proof to anyone verifying that sender had sent the message to receiver, even if the person does not trust the receiver.

Non-repudiation implies authentication. Authentication can be done more efficiently using method like MAC, but non-repudiation requires a digital signature, it is more mathematically involved and more on the legal side, therefore it makes sense to use authenticity as a separate concept.